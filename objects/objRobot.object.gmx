<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprRobotSmall</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>clsPlaceable</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initialize
num_sensors = 21;
angles[num_sensors - 1] = 90;
angles[(num_sensors - 1) / 2] = 0;
angles[0] = 270;
max_sensor_range = 128;
var i, a_diff;
a_diff = 90 / ((num_sensors - 1) / 2);
for (i = 1; i &lt; ((num_sensors - 1) / 2); i++) {
    angles[((num_sensors - 1) / 2) + i] = scrNormalizeAngle(a_diff * i);
    angles[((num_sensors - 1) / 2) - i] = scrNormalizeAngle(360 - (a_diff * i));
}
sensor_ranges[num_sensors - 1] = 0;
for (i = 0; i &lt; num_sensors; i++) {
    sensor_ranges[i] = 0;
}
sensor_xs[num_sensors - 1] = 0;
for (i = 0; i &lt; num_sensors; i++) {
    sensor_xs[i] = 0;
}
sensor_ys[num_sensors - 1] = 0;
for (i = 0; i &lt; num_sensors; i++) {
    sensor_ys[i] = 0;
}
ubuf = buffer_create(32 * 60 * 5 * 2, buffer_grow, 1); // Every entry is composed of 2 signed 8-bit numbers - d_dist, d_dir
zbuf = buffer_create(32 * 60 * 5 * num_sensors, buffer_grow, 2); // Every entry is composed of num_sensors 16-bit values giving the distance away from any solid block in the direction of the sensor.
var abuf;
abuf = buffer_create(num_sensors * 2, buffer_fixed, 2); // A buffer used to save the angles of the sensors to a file
buffer_write(ubuf, buffer_s16, 0); // initially 0 d_dist and 0 d_dir
buffer_write(ubuf, buffer_s16, 0);
for (i = 0; i &lt; num_sensors; i++) {
    buffer_write(abuf, buffer_u16, angles[i]);
    var a = scrGetDistance(x,y,max_sensor_range,scrNormalizeAngle(direction + angles[i]));
    sensor_ranges[i] = a[0];
    sensor_xs[i] = a[1];
    sensor_ys[i] = a[2];
    buffer_write(zbuf, buffer_u16, sensor_ranges[i]);
}
buffer_save(abuf, "Angles.data");
buffer_delete(abuf);
wasRunning = 0;
start_x = x;
start_y = y;
start_dir = direction;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Free Memory
buffer_delete(ubuf);
buffer_delete(zbuf);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Handle movement
/*var dr, dl, db, dx, dy, ddist, ddir, dtheta, step_size, rc, xy, dtheta_deg;
step_size = 4;
dl = 0;
dr = 0;
db = 16;
if (keyboard_check(vk_up)) {
    dl = step_size;
    dr = step_size;
}
if (keyboard_check(vk_right)) {
    dl = step_size;
}
if (keyboard_check(vk_left)) {
    dr = step_size;
}
if (keyboard_check(vk_down)) {
    dl = -step_size;
    dr = -step_size;
}
dtheta = (dr - dl) / db;
ddist = (dr + dl) / 2;
rc = ddist / dtheta;
dtheta_deg = dtheta * 180 / pi;
xy = 2 * rc * sin(dtheta_deg / 2);
dx = xy * cos(direction + (dtheta_deg/2));
dy = xy * sin(direction + (dtheta_deg/2));
if (dr != 0 and dl != 0) {
    x += dx;
    y += dy;
    direction += dtheta_deg;
}*/
var ddist, ddir;
ddist = 0;
ddir = 0;
if (keyboard_check(vk_up)) {
    ddist = 4;
}
if (keyboard_check(vk_down)) {
    ddist = -4;
}
if (keyboard_check(vk_left)) {
    ddir = 9;
}
if (keyboard_check(vk_right)) {
    ddir = -9;
}
if (ddir != 0) {
    direction += ddir;
}
if (instance_exists(objControl) and objControl.state == SimState.run and objControl.running_length &lt; objControl.sim_length) {
    var before_x, before_y;
    before_x = x;
    before_y = y;
    if (ddist &gt; 0) {
        move_contact_solid(direction, ddist);
    }
    else if (ddist &lt; 0) {
        move_contact_solid(scrNormalizeAngle(direction + 180), abs(ddist));
    }
    var i;
    for (i = 0; i &lt; num_sensors; i++) {
        var a = scrGetDistance(x,y,max_sensor_range,scrNormalizeAngle(direction + angles[i]));
        sensor_ranges[i] = a[0];
        sensor_xs[i] = a[1];
        sensor_ys[i] = a[2];
        buffer_write(zbuf, buffer_u16, sensor_ranges[i]); // save sensor ranges into z
    }
    var actual_dist = distance_to_point(before_x, before_y);
    buffer_write(ubuf, buffer_s16, actual_dist); // save d_dist and d_dir into u
    buffer_write(ubuf, buffer_s16, ddir);
    objControl.running_length++;
    wasRunning = 1;
} else if (instance_exists(objControl) and objControl.state != SimState.run and wasRunning) {
    // Save buffers to files and reset robot and clear buffers
    wasRunning = 0;
    buffer_save(ubuf, "Controls.data");
    buffer_save(zbuf, "Measurements.data");
    var length_buf = buffer_create(100, buffer_grow, 1);
    buffer_write(length_buf, buffer_string, string(objControl.running_length));
    buffer_save(length_buf, "number_of_steps.data");
    buffer_delete(length_buf);
    instance_create(start_x, start_y, objRobot);
    instance_destroy();
} else if (instance_exists(objControl) and objControl.running_length &gt;= objControl.sim_length) {
    objControl.state = SimState.observe;
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw Self and Rays
draw_sprite_ext(sprite_index, image_index, x, y, 1, 1, direction, c_white, 1);
var ccc = draw_get_color();
draw_set_color(c_red);
for (i = 0; i &lt; num_sensors; i++) {
    draw_line(x, y, sensor_xs[i], sensor_ys[i]);
}
draw_set_color(ccc);

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
