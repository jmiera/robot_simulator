<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprRobotSmall</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>clsPlaceable</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initialize
num_sensors = 21;
angles[num_sensors - 1] = 90;
angles[(num_sensors - 1) / 2] = 0;
angles[0] = 270;
max_sensor_range = 128;
sensor_std_dev = 3;
var i, a_diff;
a_diff = 90 / ((num_sensors - 1) / 2);
for (i = 1; i &lt; ((num_sensors - 1) / 2); i++) {
    angles[((num_sensors - 1) / 2) + i] = scrNormalizeAngle(a_diff * i);
    angles[((num_sensors - 1) / 2) - i] = scrNormalizeAngle(360 - (a_diff * i));
}
sensor_ranges[num_sensors - 1] = 0;
for (i = 0; i &lt; num_sensors; i++) {
    sensor_ranges[i] = 0;
}
sensor_xs[num_sensors - 1] = 0;
for (i = 0; i &lt; num_sensors; i++) {
    sensor_xs[i] = 0;
}
sensor_ys[num_sensors - 1] = 0;
for (i = 0; i &lt; num_sensors; i++) {
    sensor_ys[i] = 0;
}
forward_speed = 4;
backward_speed = 4;
turn_speed = 9;
dist_std_dev = 0.5;
dir_std_dev = 0.5;
ubuf = buffer_create(32 * 60 * 2 * 2, buffer_grow, 1); // Every entry is composed of 2 signed 8-bit numbers - d_dist, d_dir
zbuf = buffer_create(32 * 60 * 2 * (num_sensors * 2), buffer_grow, 2); // Every entry is composed of num_sensors 16-bit values giving the distance away from any solid block in the direction of the sensor.
ubuf_noisy = buffer_create(32 * 60 * 2 * (2 * 4), buffer_grow, 4); // The buffer that contains the controls at each time step plus additive gaussian noise (2 32-bit floats: d_dist, d_dir)
zbuf_noisy = buffer_create(32 * 60 * 2 * (num_sensors * 4), buffer_grow, 4); // The buffer that contains the measurements at each time step plus additive gaussian noise (num_sensors 32-bit floats)
xbuf = buffer_create(32 * 60 * 2 * (4 + 4 + 4), buffer_grow, 4); // Stores the actual state at each step (3 64-bit floats - x, y, direction)
xbuf2 = buffer_create(32 * 60 * 2 * (8 + 8 + 8), buffer_grow, 8);
var abuf;
abuf = buffer_create(num_sensors * 2, buffer_fixed, 2); // A buffer used to save the angles of the sensors to a file
buffer_write(ubuf, buffer_s16, 0); // initially 0 d_dist and 0 d_dir
buffer_write(ubuf, buffer_s16, 0);
buffer_write(ubuf_noisy, buffer_f32, 0); // Same for noisy buffer
buffer_write(ubuf_noisy, buffer_f32, 0);
buffer_write(xbuf, buffer_f32, x);
buffer_write(xbuf, buffer_f32, y);
buffer_write(xbuf, buffer_f32, direction);
buffer_write(xbuf2, buffer_f64, x);
buffer_write(xbuf2, buffer_f64, y);
buffer_write(xbuf2, buffer_f64, direction);
for (i = 0; i &lt; num_sensors; i++) {
    buffer_write(abuf, buffer_u16, angles[i]);
    var a = scrGetDistance(x,y,max_sensor_range,scrNormalizeAngle(direction + angles[i]));
    sensor_ranges[i] = a[0];
    sensor_xs[i] = a[1];
    sensor_ys[i] = a[2];
    buffer_write(zbuf, buffer_u16, sensor_ranges[i]);
    buffer_write(zbuf_noisy, buffer_f32, sensor_ranges[i] + gauss(0, sensor_std_dev));
}
buffer_save(abuf, "Angles.data");
buffer_delete(abuf);
wasRunning = 0;
start_x = x;
start_y = y;
start_dir = direction;
previous_path_point = self;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Free Memory
with (objPath) {instance_destroy();}
buffer_delete(ubuf);
buffer_delete(zbuf);
buffer_delete(xbuf);
buffer_delete(ubuf_noisy);
buffer_delete(zbuf_noisy);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Handle movement
var ddist, ddir;
ddist = 0;
ddir = 0;
var before_x, before_y;
before_x = x;
before_y = y;
if (keyboard_check(vk_up)) {
    ddist = forward_speed;
}
if (keyboard_check(vk_down)) {
    ddist = -backward_speed;
}
if (keyboard_check(vk_left)) {
    ddir = turn_speed;
}
if (keyboard_check(vk_right)) {
    ddir = -turn_speed;
}
if (ddir != 0) {
    direction += ddir;
}
if (instance_exists(objControl) and objControl.state == SimState.run and objControl.running_length &lt; objControl.sim_length) {
    if (ddist &gt; 0) {
        move_contact_solid(direction, ddist);
    }
    else if (ddist &lt; 0) {
        move_contact_solid(scrNormalizeAngle(direction + 180), abs(ddist));
    }
    var i;
    for (i = 0; i &lt; num_sensors; i++) {
        var a = scrGetDistance(x,y,max_sensor_range,scrNormalizeAngle(direction + angles[i]));
        sensor_ranges[i] = a[0];
        sensor_xs[i] = a[1];
        sensor_ys[i] = a[2];
        buffer_write(zbuf, buffer_u16, sensor_ranges[i]); // save sensor ranges into z
        buffer_write(zbuf_noisy, buffer_f32, sensor_ranges[i] + gauss(0, sensor_std_dev)); // save noisy sensor ranges into noisy z
    }
    var actual_dist = sqrt(power(x - before_x, 2) + power(y - before_y, 2));// distance_to_point(before_x, before_y);
    if (DRAW_ROBOT_PATH and actual_dist &gt; 0) {
        var inst = instance_create(x, y, objPath);
        inst.prevPath = previous_path_point;
        previous_path_point = inst;
    }
    // if (actual_dist != abs(ddist)) {show_debug_message("Ran into wall! x=" + string(x) + ", before_x=" + string(before_x));}
    buffer_write(ubuf, buffer_s16, actual_dist); // save d_dist and d_dir into u
    buffer_write(ubuf, buffer_s16, ddir);
    buffer_write(ubuf_noisy, buffer_f32, actual_dist + gauss(0, dist_std_dev));
    buffer_write(ubuf_noisy, buffer_f32, ddir + gauss(0, dir_std_dev));
    buffer_write(xbuf, buffer_f32, x);
    buffer_write(xbuf, buffer_f32, y);
    buffer_write(xbuf, buffer_f32, direction);
    buffer_write(xbuf2, buffer_f64, x);
    buffer_write(xbuf2, buffer_f64, y);
    buffer_write(xbuf2, buffer_f64, direction);
    objControl.running_length++;
    wasRunning = 1;
} else if (instance_exists(objControl) and objControl.state != SimState.run and wasRunning) {
    // Save buffers to files and reset robot and clear buffers
    wasRunning = 0;
    buffer_save(ubuf, "Controls.data");
    buffer_save(zbuf, "Measurements.data");
    buffer_save(ubuf_noisy, "Controls_Noisy.data");
    buffer_save(zbuf_noisy, "Measurements_Noisy.data");
    buffer_save(xbuf, "State.data");
    buffer_save(xbuf2, "State.part");
    var length_buf = buffer_create(100, buffer_grow, 1);
    buffer_write(length_buf, buffer_string, string(objControl.running_length));
    buffer_save(length_buf, "number_of_steps.data");
    buffer_delete(length_buf);
    instance_create(start_x, start_y, objRobot);
    instance_destroy();
} else if (instance_exists(objControl) and objControl.running_length &gt;= objControl.sim_length) {
    objControl.state = SimState.observe;
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw Self and Rays
draw_sprite_ext(sprite_index, image_index, x, y, 1, 1, direction, c_white, 1);
var ccc = draw_get_color();
draw_set_color(c_red);
for (i = 0; i &lt; num_sensors; i++) {
    draw_line(x, y, sensor_xs[i], sensor_ys[i]);
}
draw_set_color(ccc);

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
